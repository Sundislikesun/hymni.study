## 최소 스패닝 트리 (MST, Minimum cost spanning tree)



### 스패닝 트리 (spanning tree)

그래프에 있는 모든 정점을 포함하는 부분 그래프

**N개의 정점(vertex)와 N-1개의 간선(edge)으로 구성** 

간선들이 트리 형태이며, 간선들이 **정점들을 전부 연결**해야 한다.

> 간선이 트리 형태여야 한다?
>
> 선택된 간선들이 **사이클(cycle)을 이루지 않는다**는 의미 

연결 그래프에서 1개 이상의 스패닝 트리를 얻을 수 있다. 

![스패닝 트리](https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree.png)

 </br>

#### DFS, BFS로 얻을 수 있는 스패닝 트리

연결 그래프에서, DFS나 BFS는 암묵적으로 그래프 G의 간선(edge)을 두 개의 집합으로 분리한다. 

* T : 스패닝 트리의 edge 집합으로 사용되거나 search 도중에 방문
* N : 남아있는 edge의 집합

아래 그림에서 V(정점)는 8개, E(간선)은 7개이다. 

(만약 edge가 vertext의 개수와 같아지면 cycle이 생긴다. )

![dfs bfs spanning tree](https://t1.daumcdn.net/cfile/tistory/99099C435BAB4FC131)

(a) DFS spanning tree : **아직 방문하지 않은 정점으로 향하는 간선이 있으면 그 간선을 무조건 따라간다.**  가능한 한 그래프 안으로 '깊이' 간선을 따라가며, **막힌 정점에 도달하면 뒤로 돌아간다.** 

(b) BFS spanning tree : 각 정점을 방문할 때 마다 모든 **인접 정점**을 검사하므로 V0에서 V1과 V2 쪽으로 순차적으로 두 간선을 방문한다.  

 </br>

### 최소 스패닝 트리 (minimum cost spanning tree)

가중치 그래프의 스패닝 트리 중, 가중치의 합이 가장 작은 트리

즉, 그래프의 연결성은 유지하되 가장 '저렴한' 그래프

> 정점이 N개라면, 간선은 N-1개만을 포함한다. 
>
> 사이클을 만드는 간선은 선택하지 않는다. 

</br>

--------------------

####  최소 스패닝 트리 알고리즘 

크루스칼(Kruskal), 프림(Prim), 솔린(Sollin) 알고리즘이 대표적

세 알고리즘 모두 탐욕 알고리즘이다. 

> 탐욕 알고리즘(greedy method)
>
> 각 단계에서 어떤 기준을 두고 최선의 선택을 한다. 

 </br>

#### 1. 크루스칼

상호 배타적 집합 자료 구조의 사용 예 

**모든 간선(edge)을 가중치의 오름차순으로 정렬한다.** 

특정 노드에서 시작하는게 아니다. 

**모든 간선 중에서** 가중치가 가장 작은 edge를 선택하여 스패닝 트리에 **하나씩 추가**해 간다. 

이 때, 추가하면 사이클이 생기는 간선을 확인하여 제외시킨다. 

> **사이클이 발생했는지 판단하는 기준**
>
> Union-Find DisjointSet (유니온 파인드 상호배타적 집합) 자료구조를 이용하여 O(1)에 확인 가능

</br>

#### 크루스칼 알고리즘 탐색 예시  

![](https://media.vlpt.us/images/fldfls/post/bfc8ca76-a339-45c2-b1cd-17be367b9f8c/image.png)

> 간선 가중치를 정렬한 결과  **10, 12, 14, 16, 18, 22, 24, 25, 28**

그림 **(f)** 와  **(g)** 를 눈여겨보자. 

(f) 10, 12, 14, 16을 추가한 트리

(g) 18을 추가하면 사이클이 발생하므로 18을 제외시키고, 22를 추가한다. 

</br>

#### 2. 프림 

다익스트라 알고리즘과 비슷

하나의 정점으로 구성된 트리에서 시작한다.

여기에 간선을 **하나씩 추가**하며 스패닝 트리가 될 때까지 키워 간다.

**이미 만들어진 트리에 인접한 간선만 고려**한다. 

*(인접한 간선만 고려한다는것 빼고는 크루스칼과 완전히 똑같다. )*



시작 정점으로 부터 인접한 정점을 Priority Queue(pq)에 저장하는데, 이때 인접 정점과 간선의 가중치를 함께 저장한다. 

</br>

#### 프림 알고리즘 탐색 예시 

<img src="http://yimoyimo.tk/images/prim.png" style="zoom:150%;" />

</br>

### (코드) 프림 알고리즘 구현



</br>

### 크루스칼 vs 프림

|                크루스칼                |                           프림                           |
| :------------------------------------: | :------------------------------------------------------: |
|             간선 선택 기반             |                      정점 선택 기반                      |
| 간선의 가중치를 기준으로 정렬하고 시작 | 인접 정점위주로 비교하므로 자료구조의 성능에 영향을 받음 |
| 정렬할 간선의 개수가 적은 경우에 유리  |      간선의 개수가 많은 경우에 프림 알고리즘이 유리      |



--------------

## 문제 : LAN 근거리 네트워크 

[LAN 문제링크](https://algospot.com/judge/problem/read/LAN) 

#### 문제

근거리 네트워크(LAN, Local Area Network)는 가정, 학교, 혹은 회사 등의 제한된 공간 내의 컴퓨터들을 연결하는 네트워크입니다. 알고스팟 대학교에서는 캠퍼스의 일부 건물들만이 서로 근거리 네트워크로 연결되어 있었는데, 이번에 캠퍼스 정보화 사업의 일환으로 모든 건물을 모두 연결하려고 합니다. 모든 건물이 서로 연결되어 있다는 것은 건물 사이의 케이블을 이용해 모든 건물 간에 서로 직접/간접적으로 데이터를 주고받을 수 있다는 것을 의미합니다.

문제를 단순화하기 위해, 모든 건물들은 2차원 평면 위에 있는 점이라고 가정합시다. 두 건물을 직접 연결하려면 두 건물 사이의 거리 만큼의 케이블이 필요합니다. 케이블은 항상 두 건물만을 연결할 수 있으며, 두 케이블이 교차한다고 해서 두 케이블이 직접 연결된 것은 아닙니다.

각 건물들의 위치와 이미 설치된 케이블들에 대한 정보가 주어질 때, 모든 건물을 연결하기 위해 추가로 설치해야 할 케이블 길이의 최소 합을 계산하는 프로그램을 작성하세요.

#### 입력

입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 건물의 수 N (N <= 500) 과 이미 설치된 케이블의 수 M (M <= 2000) 이 주어집니다. 각 건물은 0번부터 N-1 번까지의 고유 번호로 구분합니다. 다음 줄에는 N 개의 정수로 0번부터 N-1 번까지 각 건물의 x 좌표가, 그 다음 줄에는 N 개의 정수로 y 좌표가 주어집니다. 각 좌표의 절대값은 1000 이하입니다. 그 후 M 줄에 각 2개의 정수로 각 케이블이 연결하는 두 건물의 번호가 주어집니다. 한 쌍의 건물을 연결하는 케이블이 두 개 이상 있을 수도 있습니다.



#### 출력

각 테스트 케이스마다 한 줄에 추가로 설치해야 할 케이블의 총 길이를 출력합니다. 10-7 이하의 상대/절대 오차가 있는 답도 정답으로 인정합니다.

#### 예제 입력

```
2
3 1
0 0 1
0 1 2
0 1
10 5
-7 -7 10 -4 10 -4 -5 0 -10 -6
6 8 -5 3 -4 6 -10 4 -7 10
9 7
7 3
9 7
5 0
8 6
```

#### 예제 출력

```
1.4142135624 
29.7042202421 
```

</br>

#### 풀이 



</br>

#### 코드



</br>

[크루스칼 알고리즘 그림 출처]([https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98](https://velog.io/@fldfls/최소-신장-트리-MST-크루스칼-프림-알고리즘))

[프림 알고리즘 그림 출처](http://yimoyimo.tk/SpanningTree/)